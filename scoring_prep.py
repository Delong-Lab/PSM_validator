import copy

##################################################################################################################################################################

def sequence_mass_calculator(sequence, amino_acids, N_term_shift, C_term_shift):
    
#Accepts an amino acid sequence and determines the m/z given a defined charge state. For hybrid sequences, the hyphen indicating the junction is assigned a mass 
    #of 0. The calculator can also accept a user-defined modification that is entered as a custom amino acid.

    mass = 2*1.007825035 + 15.99491463 + N_term_shift + C_term_shift #Accounts for the addition of H and OH for the mass of the completed N- and C-terminus, respectively.
    
    for i in range(0, len(sequence)): 
        mass = mass + amino_acids[sequence[i]]
        
    sequence_mass = mass

    return(sequence_mass)

##################################################################################################################################################################

def LR_ion_calculator(sequence, amino_acids, N_term_shift, C_term_shift, ion_type):

#Accepts an amino acid sequence and calculates the masses of all predicted singly- and doubly-charged b- and y-ions. 
#For non-hybrid sequences, b- and y-ions are assigned to the bond they describe.
#For hybrid sequences, the hyphen indicating the hybrid junction is found and designated as the junction. B- and y-ions are assigned as either L- and R-ions
    #(i.e., they are designated as ions that are generated by fragmentation of a bond on either the left or or right side of the hybrid junction, respectively).    
#The calculator can also accept a user-defined modification that is entered as a custom amino acid. 
#The function returns the number of bonds to the left of the junction, a list of predicted L-ions, the number of bonds to the right of the junction, and a list
    #of predicted R-ions. For non-hybrid sequences, the number of R-bonds is returned as 0 and the R-ions list is returned empty.

    length = len(sequence)
    
#List structure:
    #L_ions = [["bond 1", b+, b++, y+, y++],
    #          ["bond 2", b+, b++, y+, y++]]

#During b-/y-ion formation, both electrons from the amide bond remain with the nitrogen atom, generating a negatively-charged C-terminal fragment.
    #This species must accept a proton to become neutral and then another proton to become a singly-charged y-ion. 
    #The carbonyl group on the C-terminal end of the N-terminal fragment is missing an electron and forms a positively-charged acylium ion (C-O triple bond).
#Residue masses are based on the neutral masses of the amino acids with an NH group (instead of NH2) and a CO group (instead of COOH).
    #To calculate a b-ion mass, the mass of an H atom (proton + electron) must be added to complete the N-terminus and the mass of an electron must be subtracted 
    #to account for the formation of the acylium ion. To calculate a y-ion mass, the mass of OH must be added to complete the C-terminus and the mass of an H atom
    #must be added to complete the N-terminus. Then the mass of a proton must be added to provide the positive charge.

#Calculate ions for non-hybrid sequences.
    
    if sequence.find("-") == -1: #A return value of -1 for the find function indicates the character was not found in the string. The sequence in non-hybrid.
        
        L_bonds = len(sequence) - 1
        R_bonds = 0 #All bonds and ions are treated as L for non-hybrid sequences.
        L_ions, R_ions = [], []
    
        #b+/c+
        
        if ion_type == "b/y":
            total = 1.007825035 - 0.0005486 + N_term_shift #Addition of H to convert residue NH into NH2 terminus and removing an electron to generate the acylium ion (+ charge).
        elif ion_type == "c/z":
            total = 3*1.007825035 + 14.003074 + 1.007276466 + N_term_shift #Addition of H to complete N-terminus, addition of NH2 to make proper fragment, and addition of one proton to make charge.
        for i in range (0, length-1): #Last AA residue not included because no bond to cleave after the last residue.
            mass = amino_acids[sequence[i]]
            total = total + mass
            L_ions.append(["bond " + str(i+1), total])
                
        #b++/c++

        if ion_type == "b/y":                
            total = 2*1.007825035 - 2*0.0005486 + N_term_shift #Accounts for the addition of another H minus an electron to generate the ++ charge.
        elif ion_type == "c/z":
            total = 3*1.007825035 + 14.003074 + 2*1.007276466 + N_term_shift
        for i in range (0, length-1):
            mass = amino_acids[sequence[i]]
            total = total + mass
            L_ions[i].append(total/2)
                
        #y+/z+

        if ion_type == "b/y":                
            total = 3*1.007825035 + 15.99491463 - 0.0005486 + C_term_shift #Addition of OH to convert CO of residue to COOH, H to make NH into NH2, and proton to confer + charge.
        elif ion_type == "c/z":
            total = -1.007825035 + 15.99491463 - 14.003074 + 1.007276466 + C_term_shift #Addition of OH to complete C-term, removal of NH2 to make proper fragment, and addition of proton for charge.
        for i in range (length-1, 0, -1): #Starts with last residue in sequence and moves left one residue at a time. Does not include the N-terminal residue.
            mass = amino_acids[sequence[i]]
            total = total + mass
            L_ions[i-1].append(total) #Since the number of bonds is one less than the number of residues, length of L-ions is one less than the length of the 
                                          #sequence. Hence, L_ions[i-1] instead of L-ions[i].
                
        #y++/z++

        if ion_type == "b/y":                
            total = 4*1.007825035 + 15.99491463 - 2*0.0005486 + C_term_shift #Accounts for the addition of another proton to generate the ++ charge.
        elif ion_type == "c/z":
            total = -1.007825035 + 15.99491463 - 14.003074 + 2*1.007276466 + C_term_shift
        for i in range (length-1, 0, -1):
            mass = amino_acids[sequence[i]]
            total = total + mass
            L_ions[i-1].append(total/2)
        
#Calculate ions for hybrid sequences.

    else:
        junction = sequence.index("-") #Locates the hybrid junction.
        #NOTE: len(sequence) includes the hyphen indicating the hybrid junction.
        #Bonds are assigned to the left or right side of the hybrid. B-ions corresponding to a breakage of the peptide bond at the hybrid junction are designated
            #as L-ions; y-ions corresponding to breakage at the junction bond are designated as R-ions. The last ion in L_ions will be the b++-ion corresponding
            #to cleavage at the junction and the first ion in R_ions will be the y+-ion corresponding to cleavage at the junction. The last bond # in L_ions and
            #the first bond # in R_ions will be the same.
        L_bonds = junction
        R_bonds = len(sequence) - (junction + 1) #Because index function starts counting at 0, 1 must be added to junction for this calculation to work correctly.
        L_ions, R_ions = [], []

        #b+/c+

        if ion_type == "b/y":    
            total = 1.007825035 - 0.0005486 + N_term_shift
        elif ion_type == "c/z":
            total = 3*1.007825035 + 14.003074 + 1.007276466 + N_term_shift            
        for i in range (0, length-1):
            mass = amino_acids[sequence[i]]
            total = total + mass
            if i < junction: #If the broken bond is to the left of or is the junction, the b-ion is designated as L.
                L_ions.append(["bond "+str(i+1),total]) #Because i starts at 0, 1 must be added to output the correct bond number.
            elif i == junction: #The hyphen indicating the junction is treated as a residue even though it is not. Thus, i now matches the bond number. Also,
                                    #this is used as an opportunity to indicate (by appending 0 as an m/z to the R_ion list) that a b-ion describing the junction
                                    #does not contribute to the R-ion count (only the L-ion count).
                R_ions.append(["bond "+str(i),0])
            elif i > junction:
                R_ions.append(["bond "+str(i),total])
                
        #b++/c++

        if ion_type == "b/y":                
            total = 2*1.007825035 - 2*0.0005486 + N_term_shift
        elif ion_type == "c/z":
            total = 3*1.007825035 + 14.003074 + 2*1.007276466 + N_term_shift
        for i in range (0, length-1):
            mass = amino_acids[sequence[i]]
            total = total + mass
            if i < junction:
                L_ions[i].append(total/2)
            elif i == junction:
                R_ions[0].append(0)
            elif mass != 0 and i > junction:
                R_ions[i-junction].append(total/2) 
                
        #y+/z+

        if ion_type == "b/y":                
            total = 3*1.007825035 + 15.99491463 - 0.0005486 + C_term_shift
        elif ion_type == "c/z":
            total = -1.007825035 + 15.99491463 - 14.003074 + 1.007276466 + C_term_shift
        for i in range (length-1, 0, -1):
            mass = amino_acids[sequence[i]]
            total = total + mass
            if i < junction:
                L_ions[i-1].append(total)
            #This is rather confusing, so an example is helpful: Let's say i == 1 and junction == 2. The total mass will account for all residues starting from
                #the C-terminus of the peptide up to and including the second residue in the sequence. The y-ion will correspond to fragmentation of the bond
                #between the first and second residue, which is the first bond. We want the ion to be entered in the first sub-list (the bond 1 list) of L_ions.
                #That would be L_ions[0]. However, i == 1, therefore we use L_ions[i-1].append(total).
            elif i == junction:
                L_ions[i-1].append(0)
            elif i > junction:
                R_ions[i-1-junction].append(total)
            #Let's say i == 3 and junction == 2. The y-ion corresponding to fragmentation of bond #3 will be calculated. However, this bond falls on the right
                #side of the junction (the hyphen in the sequence) and is actually the hybrid bond. This y-ion should be added to the first sublist in R_ions,
                #thus we want R_ions[0].append(total). In this case, i-1-junction == 3-1-2 == 0. 
                
        #y++/z++

        if ion_type == "b/y":                
            total = 4*1.007825035 + 15.99491463 - 2*0.0005486 + C_term_shift
        elif ion_type == "c/z":
            total = -1.007825035 + 15.99491463 - 14.003074 + 2*1.007276466 + C_term_shift
        for i in range (length-1, 0, -1):
            mass = amino_acids[sequence[i]]
            total = total + mass
            if i < junction:
                L_ions[i-1].append(total/2)
            elif i == junction:
                L_ions[i-1].append(0)
            elif i > junction:
                R_ions[i-1-junction].append(total/2)            

    return(L_bonds, L_ions, R_bonds, R_ions)

##################################################################################################################################################################

def pre_mz_filter(targets, pre_mz_tol, contents):

    hits=copy.deepcopy(targets)
    scan_num=0
    for row in contents:
        if "BEGIN" in row:
            scan_start=int(contents.line_num)
            scan=[["BEGIN","IONS"]]
            scan_num=scan_num+1
        elif contents.line_num == (scan_start + 1):
            scan.append(list(row))
        elif contents.line_num == (scan_start + 2):
            RTINSECONDS=list(row)
            scan.append(RTINSECONDS)
        elif contents.line_num == (scan_start + 3): 
            PEPMASS=list(row)
            scan.append(PEPMASS)
            PEPMASS=PEPMASS[0]
            obs_pre_mz=float(PEPMASS[8:])
        elif contents.line_num == (scan_start + 4):
            CHARGE=list(row)
            scan.append(CHARGE)
            CHARGE=str(CHARGE[0])
            obs_z=int(CHARGE[7])        
        elif (contents.line_num > (scan_start + 4)) and ("END" not in row):
            peak=list(row)
            scan.append(peak)
        elif "END" in row:
            scan.append(list(row))
            for i in range(0,len(hits)):
                sequence_mass=hits[i][2]
                pre_mz = (sequence_mass + obs_z*1.0072764)/obs_z
                if (pre_mz-pre_mz/1000000*pre_mz_tol) <= obs_pre_mz <= (pre_mz+pre_mz/1000000*pre_mz_tol):
                    hits[i].append(scan)

    return(hits)

##################################################################################################################################################################